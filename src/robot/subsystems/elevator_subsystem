def _motor_rot_to_inches(rot: float) -> float:
    """Convert motor shaft rotations to height in inches."""
    return rot * ElevatorConsts.SPROCKET_CIRC * ElevatorConsts.RIG / ElevatorConsts.GEAR_RATIO + ElevatorConsts.HEIGHT_OFFSET

def _inches_to_motor_rot(height: float) -> float:
    """Convert height to motor shaft position in rotations."""
    return (height - ElevatorConsts.HEIGHT_OFFSET) * ElevatorConsts.GEAR_RATIO / ElevatorConsts.SPROCKET_CIRC / ElevatorConsts.RIG

def _configure_elevator_motor(self) -> TalonFXConfiguration:
        configuration = TalonFXConfiguration()

        configuration.motor_output.inverted = InvertedValue.CLOCKWISE_POSITIVE
        configuration.motor_output.neutral_mode = NeutralModeValue.COAST

        # Set control loop parameters for "slot 0", the profile we'll use for position control.
        configuration.slot0.k_p = 1.0  # An error of one rotation results in 1.0V to the motor.
        configuration.slot0.k_i = 0.0  # No integral control
        configuration.slot0.k_d = 0.0  # No differential component

        # TODO: Wrapping: This might let us get remove _place_in_appropriate0_to360_scope()
        # in future.  See other Wrapping TODOs.
        # configuration.feedback.sensor_to_mechanism_ratio = DriveConstants.TURN_GEAR_RATIO
        # configuration.closed_loop_general.continuous_wrap = True

        return configuration

    # Mechanical constants
    GEAR_RATIO: float = 27
    HEIGHT_OFFSET: float = 10.5 # Height of the second stage's lower crosspiece (top surface), in inches.
    
    # Heights in inches (lowest is 10.5, highest is ~55.5)  #Change names of the different heights when writing the offical code
    HOME: float = 10.5 # Elevator at its lowest position.
    MID: float  = 34.5

    ELEVATOR_MOTOR = 14 # Motor ID

    




    class ElevatorSubsystem(commands2.Subsystem):
    def __init__(self) -> None:
        super().__init__() # Call the Subsystem class's (the "super" part) init.

        # ---------------------------------------------------------------------
        # Set up motors, their encoders, and the drivetrain.
        # ---------------------------------------------------------------------

        # Create the motor
        self.elevator_motor = TalonFX(ElevatorConsts.ELEVATOR_MOTOR)

        # Apply it to the motor.
        self.elevator_motor.configurator.apply(self._configure_elevator_motor())

        # A controller is how we adjust positions.

        self.encoder = self.elevator_motor.getEncoder()

        self.bottom_limit = self.motor.getReverseLimitSwitch()  #Plan for having 2 limit switch. One at the bottom and one at the highest height we want to go to 

        # Position request starts at position 0, but can be modified later.
        self.position_request = PositionVoltage(0).with_slot(0)

        # Give an initial position in rotations we are trying to get to.
        self.goal_pos = _inches_to_motor_rot(ElevatorConsts.HOME)

        # Make sure we initialize the encoder properly.
        self.initialized: bool = False
        if self.bottom_limit.get():
            self.encoder.setPosition(_inches_to_motor_rot(ElevatorConsts.HOME))
            self.initialized = True


    ###########################################################################
    # Methods in base classes that we override here                           #
    ###########################################################################

    def periodic(self):
        """
        This method runs once every 20 msec in all modes (including simulation).  
        """
        # Send data to the dashboard
        # TODO: implement shuffleboard
        height = _motor_rot_to_inches(self.encoder.getPosition())
        wpilib.SmartDashboard.putString('DB/String 4', 'elev: {:5.2f}"'.format(height))

    def simulationPeriodic(self):
        """Called in simulation after periodic() to update simulation variables."""
        pass

    ###########################################################################
    # Methods that create commands                                            #
    ###########################################################################

    ###########################################################################
    # Methods to use in commands, either created in this class or elsewhere   #
    ###########################################################################

    def set_goal_height_inches(self, height: float):
        """Set the goal in inches that the elevator drives toward"""
        # Convert because internally, we use rotations.
        self.goal_pos = _inches_to_motor_rot(height)

    def move_to_goal(self):
        """Move toward the goal position"""
        if self.initialized:
            self.controller.setReference(self.goal_pos, rev.SparkMax.ControlType.kPosition)
        else:
            # If not initialized, move downward slowly to find the bottom.
            self.motor.set(-0.1)
            if self.bottom_limit.get():
                self.motor.set(0.0)
                self.encoder.setPosition(_inches_to_motor_rot(ElevatorConsts.HOME))
                self.initialized = True

    def is_at_goal(self) -> bool:
        False # Never end unless interrupted.



class ElevatorCommands:
    """Container for elevator command factories."""

    def __init__(self):
        raise Exception("This is a utility class, don't make instances of it.")
                        
    @staticmethod
    def move_goal(goal: float, elev: subsystems.elevatorsubsystem.ElevatorSubsystem):
        """
        A command that moves the elevator toward a goal height in inches.
        :param: goal  The height to move toward.
        :param: elev  The elevator subsystem to operate on.
        """
        return commands2.cmd.FunctionalCommand(
            # Initialize by setting the goal.
            lambda: elev.set_goal_height_inches(goal),

            # Move while command is executing.
            elev.move_to_goal,

            # What to do when ending, the parameter "interrupt" will be true if
            #  the command was interrupted, but we ignore it.  Don't do anything.
            lambda interrupt: None,

            # Call this to know when to end the command.
            elev.is_at_goal,

            # Require the elevator subsystem that is passed in.
            elev
        )
